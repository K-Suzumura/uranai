<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>占いの館</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            background: white;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
        }
        .input-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
        }
        .input-row {
            display: flex;
            gap: 20px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }
        .input-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        label {
            font-weight: bold;
            color: #555;
            white-space: nowrap;
        }
        input, select {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 30px;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            display: block;
            margin: 20px auto;
        }
        button:hover {
            background: #5a67d8;
        }
        .result-section {
            display: none;
        }
        .meishiki-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        .meishiki-table th, .meishiki-table td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: center;
        }
        .meishiki-table th {
            background: #667eea;
            color: white;
        }
        .pillar {
            background: #f8f9fa;
        }
        .analysis-section {
            margin-top: 30px;
            padding: 20px;
            background: #f0f0f0;
            border-radius: 8px;
        }
        .analysis-item {
            margin-bottom: 15px;
            padding: 15px;
            background: white;
            border-radius: 5px;
            border-left: 5px solid #667eea;
        }
        .analysis-title {
            font-weight: bold;
            color: #667eea;
            margin-bottom: 5px;
            font-size: 1.1em;
        }
        .element-balance {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        .element-bar {
            flex: 1;
            text-align: center;
            padding: 5px;
            border-radius: 5px;
            color: white;
        }
        .wood { background: #4a7c59; }
        .fire { background: #e63946; }
        .earth { background: #8b4513; }
        .metal { background: #708090; }
        .water { background: #2a9d8f; }
        .stem-select, .branch-select {
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            background: white;
        }
        .daiunn-section, .nenun-section {
            margin-top: 20px;
            padding: 15px;
            background: #f9f9f9;
            border-radius: 8px;
        }
        .daiunn-table, .nenun-table {
            width: 100%;
            margin-top: 10px;
            font-size: 14px;
        }
        .daiunn-table th, .nenun-table th {
            background: #667eea;
            color: white;
            padding: 5px;
        }
        .daiunn-table td, .nenun-table td {
            padding: 5px;
            text-align: center;
            border: 1px solid #ddd;
        }
        .daiunn-table td:last-child, .nenun-table td:last-child {
            text-align: left;
            padding: 8px;
            line-height: 1.5;
        }
        .transformed {
            color: red;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🔮 占いの館 🔮</h1>
        
        <div class="input-section">
            <h2>生年月日、出生時刻、性別を入力してください</h2>
            <div class="input-row">
                <div class="input-group">
                    <label>生年月日：</label>
                    <input type="date" id="birthDate" value="1990-01-01">
                </div>
                <div class="input-group">
                    <label>出生時刻：</label>
                    <input type="time" id="birthTime" value="12:00">
                </div>
                <div class="input-group">
                    <label>性別：</label>
                    <select id="gender">
                        <option value="male">男性</option>
                        <option value="female">女性</option>
                    </select>
                </div>
                <button onclick="calculate()">命式を算出する</button>
            </div>
        </div>
        
        <div id="resultSection" class="result-section">
            <h2>命式</h2>
            <table class="meishiki-table">
                <thead>
                    <tr>
                        <th>種類</th>
                        <th>時柱</th>
                        <th>日柱</th>
                        <th>月柱</th>
                        <th>年柱</th>
                    </tr>
                </thead>
                <tbody>
                    <tr class="pillar">
                        <td><strong>天干</strong></td>
                        <td>
                            <select id="hourStem" class="stem-select" onchange="updateAnalysis()">
                                <option value="">-</option>
                            </select>
                        </td>
                        <td style="background: #ffd700;">
                            <select id="dayStem" class="stem-select" onchange="updateAnalysis()">
                                <option value="">-</option>
                            </select>
                        </td>
                        <td>
                            <select id="monthStem" class="stem-select" onchange="updateAnalysis()">
                                <option value="">-</option>
                            </select>
                        </td>
                        <td>
                            <select id="yearStem" class="stem-select" onchange="updateAnalysis()">
                                <option value="">-</option>
                            </select>
                        </td>
                    </tr>
                    <tr class="pillar">
                        <td><strong>地支</strong></td>
                        <td>
                            <select id="hourBranch" class="branch-select" onchange="updateAnalysis()">
                                <option value="">-</option>
                            </select>
                        </td>
                        <td>
                            <select id="dayBranch" class="branch-select" onchange="updateAnalysis()">
                                <option value="">-</option>
                            </select>
                        </td>
                        <td>
                            <select id="monthBranch" class="branch-select" onchange="updateAnalysis()">
                                <option value="">-</option>
                            </select>
                        </td>
                        <td>
                            <select id="yearBranch" class="branch-select" onchange="updateAnalysis()">
                                <option value="">-</option>
                            </select>
                        </td>
                    </tr>
                    <tr>
                        <td><strong>蔵干</strong></td>
                        <td id="hourHidden"></td>
                        <td id="dayHidden"></td>
                        <td id="monthHidden"></td>
                        <td id="yearHidden"></td>
                    </tr>
                    <tr>
                        <td><strong>蔵干通変星</strong></td>
                        <td id="hourHiddenGod"></td>
                        <td id="dayHiddenGod"></td>
                        <td id="monthHiddenGod"></td>
                        <td id="yearHiddenGod"></td>
                    </tr>
                    <tr>
                        <td><strong>通変星</strong></td>
                        <td id="hourGod"></td>
                        <td>日主</td>
                        <td id="monthGod"></td>
                        <td id="yearGod"></td>
                    </tr>
                    <!-- 十二運の行を削除 -->
                    <!--
                    <tr>
                        <td><strong>十二運</strong></td>
                        <td id="hour12"></td>
                        <td id="day12"></td>
                        <td id="month12"></td>
                        <td id="year12"></td>
                    </tr>
                    -->
                </tbody>
            </table>
            
            <div class="analysis-section">
                <h2>占い結果</h2>
                <div id="analysisResult"></div>
            </div>
            
            <div class="daiunn-section" id="daiunnSection" style="display: none;">
                <h3>大運（10年ごとの運勢）</h3>
                <div id="daiunnResult"></div>
            </div>

            <!-- New section for Nenun (Yearly Luck) -->
            <div class="nenun-section" id="nenunSection" style="display: none;">
                <h3>年運（1年ごとの運勢）</h3>
                 <div class="input-row" style="margin-bottom: 10px;">
                    <div class="input-group">
                        <label for="nenunStartYear">開始年:</label>
                        <input type="number" id="nenunStartYear" value="2024" style="width: 80px;">
                        <button onclick="updateNenun()" style="margin: 0 0 0 10px; padding: 5px 15px;">再計算</button>
                    </div>
                </div>
                <div id="nenunResult"></div>
            </div>
        </div>
    </div>

    <script>
        // Data definitions
        const heavenlyStems = ['甲', '乙', '丙', '丁', '戊', '己', '庚', '辛', '壬', '癸'];
        const stemElements = { '甲': '木', '乙': '木', '丙': '火', '丁': '火', '戊': '土', '己': '土', '庚': '金', '辛': '金', '壬': '水', '癸': '水' };
        const stemYinYang = { '甲': '陽', '乙': '陰', '丙': '陽', '丁': '陰', '戊': '陽', '己': '陰', '庚': '陽', '辛': '陰', '壬': '陽', '癸': '陰' };
        const earthlyBranches = ['子', '丑', '寅', '卯', '辰', '巳', '午', '未', '申', '酉', '戌', '亥'];
        const branchElements = { '子': '水', '丑': '土', '寅': '木', '卯': '木', '辰': '土', '巳': '火', '午': '火', '未': '土', '申': '金', '酉': '金', '戌': '土', '亥': '水' };
        const twelveStages = ['胎', '養', '長生', '沐浴', '冠帯', '建禄', '帝旺', '衰', '病', '死', '墓', '絶'];

        const elements = {
            wood: ['甲', '乙', '寅', '卯'],
            fire: ['丙', '丁', '巳', '午'],
            earth: ['戊', '己', '丑', '辰', '未', '戌'],
            metal: ['庚', '辛', '申', '酉'],
            water: ['壬', '癸', '子', '亥']
        };

        const kakkyokuDescriptions = {
            // Normal Patterns (普通格局)
            '建禄格': { title: '目的のために頑張りがきく創業者', description: '独立心が旺盛で、率直で向こう気の強い人です。見かけは平静を装っていても負けず嫌い。意志が強く、目的を達するまで張り抜きます。どのような場にあっても自分を中心とした影響力の渦を作ります。' },
            '月刃格': { title: '芯が強く忍耐力のある謀略家', description: '自尊心が強いにもかかわらず、何を考えているのか分かりにくい人です。心の中では自分を高く見ており、力ずくで勝敗をつけようとする癖があります。負けず嫌いで、巻き返しのチャンスを虎視眈眈とねらいます。' },
            '食神格': { title: '感覚とロマンに生きる芸術家', description: '気持ちのよいこと、おいしいものが大好きな人です。心は広く大らかで、物事に対して楽観的。華やかな芸術の才能に満ちており、温和さと優雅な雰囲気で人を魅了します。' },
            '傷官格': { title: '頭の切れの鋭い技術者', description: '技術の習得がとても速く、巧みに新しい技術を学びます。頭の回転が速く、非常にクリエイティブ。感覚的で洗練されたものを好み、センスがよくて、流行に敏感です。' },
            '偏財格': { title: '社交的で人格円満な商売人', description: '人づき合いがとても好きな人です。人の集まるところが大好きで、社交や人助けのために年中飛び回っています。多くの人を楽ませ、たくさんもてなすことで、大きな価値を生み出そうとします。' },
            '正財格': { title: '誠実で勤勉に働く銀行マン', description: '誠実で勤勉な人です。質実剛健、まじめで信用されます。経験を重視し、人間関係を大切にする穏健派。地に汗して働くことをいとわず、コツコツと実績を重ねるタイプです。' },
            '偏官格': { title: '偉業と功績を上げる英雄', description: '正義感が強く、義理と人情に生きる人です。弱い者を助け、竹を割ったようなサッパリとした気性。人生において大きな野心を持ち、戦うことや失敗を恐れず、試練にもよく耐えます。' },
            '正官格': { title: '礼儀と規律を守る国家公務員', description: '規律を守り、組織のルールに従う人です。高貴で優雅な気質を備えています。知的であり、規則を守って順序よく行動します。どのような環境にあっても、法を守り、自分のことよりも人のために尽くします。' },
            '偏印格': { title: '臨機応変で時間にとらわれない記者', description: '物質世界よりも、内面の世界を重視する人です。知的好奇心が旺盛で、直感が非常に発達していて、物事の核心をつかむ洞察力があります。束縛されることを嫌い、孤独な時間を楽しむところがあります。' },
            '印綬格': { title: 'インテリで研究熱心な学者', description: '好奇心が旺盛な人です。聡明で豊富な知識を持ち、控えめです。何よりも学ぶことが好きで、記憶力がよく、様々な知識を吸収します。伝統や、正統な学問、学術を重んじる秀才です。' },
            // Special Patterns (特別格局) - Updated with details from PDF
            '従旺格': { title: '我が道を歩む独立独歩の人', description: '自分自身の集合体でもある従旺格は、我が道をマイペースにまっすぐに歩む人生です。普通の人とは全く違う感覚と人生観を持っています。自我が強く、主観を貫くと良い人生となります。多くの友人や兄弟姉妹に助けられ、暖簾を守るような商家や寺の跡継ぎに生まれることも多いでしょう。' },
            '従強格': { title: '知的好奇心旺盛な学究の人', description: '偏印と印綬ばかりの従強格の人は、学識の充実した人生を歩む人です。知的好奇心と学習力に優れており、秀才で、多くの本に囲まれて生活するでしょう。自我が強く聡明で、師や母親のように教え育てる人に囲まれ、生涯を通じてその教導によって成長します。' },
            '従児格': { title: '芸術的才能に溢れたクリエイター', description: '命式が食神と傷官で占められ、創造力や企画力、芸術、技術などの才能が最大限に発揮される人生を送ります。頭の回転が速く、どのような場にあってもクリエイティブで芸術的な才能を発揮します。時代の流行をいち早くとらえ、ヒット商品を生み出します。' },
            '従財格': { title: '人脈と財を築く社交的な商才人', description: '命式が偏財と正財で占められ、不動産、動産、人脈などを獲得する才能が最大限に発揮される人生です。人を喜ばせたりもてなしたりするのがうまく、お金を儲けて財産を築く能力を発揮し、お金に極めて恵まれた人生を送ります。' },
            '従殺格': { title: '組織の中で地位を築く権威の人', description: '命式が偏官と正官で占められ、地位、権威、役職などに任ずる才能が最大限に発揮される人生を送ります。組織にあって上の命令に従い任務を遂行し、忍耐強く物事に取り組みます。管理能力に優れ、社会的に高い地位と権力を得ます。' },
            '従勢格': { title: '時代の流れに乗る柔軟な世渡り上手', description: '自分以外の勢いに従う格局で、周りの環境や状況に柔軟に対応していくことで幸運を引き寄せます。様々な才能に満ちあふれており、富にも地位にも恵まれる人生を送ります。性格は円満で多くの人に好かれ、世渡りが上手です。' },
        };
        
        // Data from PDF for Nenun (Yearly Luck)
        const nenunFortunes = {
            '比肩': {
                weak: '自立心が強くなり、挑戦意欲が高まるときです。初志貫徹してけじめをつけます。目の前にある困難をはねのけようと奮闘するでしょう。会社員は、転勤や転職などで自分の望む仕事環境につくか、独立して束縛のない自由な環境で仕事ができるようになるでしょう。自営業の人は、新しい市場に参入することや、新商品を開発することで事業が進展するでしょう。もし、転職や独立を考えているのであれば、チャンスはこの時期です。友人や兄弟姉妹の助力が得られるときですが、無理に求めなくても、一生懸命に努力奮闘しているうちに、将来の見通しは開けてきます。',
                strong: '自我が強くなり、自分本位な言動になり人間関係のトラブルを起こしがちです。会社員は、同僚と不和になったり、自分から束縛を嫌って辞職したりします。自営業の人は、独立や拡張の無理がたたって金銭的に厳しい状況に追い込まれることもあります。友人との合作事業は、互いに意見を譲らず、決裂するか共倒れになるでしょう。投機は、見込み違いで損失が大きくなりますからしてはいけません。また、兄弟姉妹や友人から金銭的な迷惑をかけられたり、意見の相違から対立したりしがちです。'
            },
            '劫財': {
                weak: '意志が強くなり、やる気が出てきます。難しそうなことでもチャレンジしてみようという気持ちが強くなります。ふつふつと闘志がわいてきます。会社員は、それまでの業績不振をはね返すような果敢な行動で成績を上げるでしょう。自営業の人は、困難を恐れず挑戦して、新しい分野を開拓するでしょう。また、この時期は、いつになく強引になりますが、それが功を奏するときなので小さなことにはこだわらず、大胆に行動しましょう。友人・兄弟からの協力が得られるので共同で何かをするのもよいでしょう。',
                strong: '自己中心的になり何事に対しても強引になります。しかし、理想と現実の狭間で苦悩におちいり、やる気をなくすか自暴自棄になってしまうでしょう。会社員は、独断で決めたことが失敗して会社で孤立無援となります。自営業の人は、得意先の倒産や手形の不渡り、仕事仲間との対立などにより、金銭的な損失を受けるでしょう。また、友人からの損害を受けます。あなたの成功の邪魔をしようとする人や足を引っ張ろうとする人が次々に現れ、物事は思うように運ばないでしょう。謙虚になり自己反省しないと、仕事、お金、愛情全ての面で絶望するような結果を招きかねません。'
            },
            '食神': {
                strong: '精神的に落ち着き、ゆったりとした豊かな毎日を送ることができます。人間関係は円満に運び、仕事も学業も順調なとき。生活は安定して、衣食住に恵まれます。趣味や娯楽に興ずることも多くなるでしょう。食べ物がおいしく感じられ、必然的にふくよかな体つきになります。友人との歓談や飲食の機会も増え、笑っていることが多いでしょう。金銭的にも困らないので、欲しいと思っていたものが手に入り、幸せ気分いっぱいです。豊かなアイデアがわき、表現する能力が高まりますから、何かを発表するチャンスです。',
                weak: 'だらしない日々におちいりやすいでしょう。やらなければならないことをしないで、遊び、飲食、映画、旅行、カラオケなどで浮かれ気分になるときです。そのため、仕事を放り出し、趣味や恋愛にうつつを抜かして人から非難されることもあるでしょう。また、不注意から損失を招いたり、気のゆるみから人につけ入られて利用されたりします。ぬるま湯につかってぼんやりしていないで、注意深くなりましょう。金銭面では浪費しがちです。遊興で散財したり、衝動的に高価なものを買ってしまったりして、後から支払いに困るということもあるでしょう。'
            },
            '傷官': {
                strong: '感性が鋭くなり、頭の回転が速くなります。打てば響くように勘が冴えます。新しい発想や企画が浮かんで才能が発揮されます。芸術方面でも認められて、発表の喜びを得ることができます。芸術的なことや、技術の習得に適しており、それに没頭すれば、かなりの成果が上がるでしょう。仕事や人間関係への問題提起をして改革を断行し、成功します。無駄なことはやめ、いらないものは取り除きます。情に流されず、合理性を重視して成果が上がります。',
                weak: 'やり場のないいらだちや焦燥感が強まります。社会への怒りや環境への不満がもとで暴走します。対人関係に摩擦を起こし、目上に反抗的になりやすいとき、仲のよかった人とも次々とトラブルを起こしてしまいます。怒りと矛盾が爆発して会社を辞めることもあります。周囲に迷惑をかける、職場で信用を失う、自分の名誉を失うなど、散々な目にあいます。場合によっては、法律に触れて刑に服すようなことにもなりかねません。とにかくこの時期は、社会、目上、上司、親などに反抗するようなことばかりしたくなるので、自分の行動が非難の的にならないように気をつけて。'
            },
            '偏財': {
                strong: '人との社交が盛んになります。そのための忙しさは頂点を極めますが、体力気力ともに充実していて楽しく活動できます。この時期は、思いがけない金運に恵まれ、大きなお金が苦労せずに転がり込んでくるのが特徴です。お金とチャンスは素早くつかみましょう。恋人や家族とも仲よく過ごし、人間関係は円満そのもの。あなたの才能や人柄が輝くときで、どこへ行っても人気者になるでしょう。必然的に、人の集まりや飲食の場、仕事の駆け引きの場に誘われることが多くなります。会社員は、活躍の場を与えられたり、給料がアップしたりします。自営業の人は、ヒット商品が出て多くの利益が出ます。',
                weak: '人の集まりや社交に追われて、忙しく走り回るのですが、その割に実りがありません。会社員は接待などで毎日酒場や遊興の場に入り浸り、業績は一向に上がりません。自営業の人は十分な下調べや準備をしないで手をつけ、利益が上がらないということになりやすいでしょう。労力をかけた割に結果が全く伴わず、周囲の人に対して面目が立たないときです。他人の世話事に振り回されて自分の本業にかける時間がなくなったら、交際に忙しすぎて自分を見失ったりしがちです。また、入ってきたお金は出て行ってしまうときですから、遊びや社交を控えるのが無難でしょう。'
            },
            '正財': {
                strong: '財運に恵まれるときです。勤勉になれば確実にお金が入ってきます。会社員は、昇給したり、報酬のよい会社に転職したりします。自営業の人は、よい条件の仕事が回ってきたり、ヒット商品が出たりして売り上げが非常に上がるときでしょう。とにかく豊富な財産に恵まれる運にあります。コツコツ働けば、多くの人の協力を得られ、何倍もの収入となって返ってきます。よい不動産にも縁のある時期です。土地やマンション、家を買う好機です。お金にゆとりのあるときなので、貯蓄だけではなく、機械などの設備に投資しておくのもよいでしょう。人間関係も好調です。',
                weak: '一生懸命に働いているにもかかわらず、金銭的に豊かにならないときです。会社員は苦労して取り組んだ仕事の成果が出なかったり、結果が期待はずれに終わったりします。自営業の人は、お金をかけて取り組んでも利益が上がらなかったり、事業が不発に終わったりします。この時期はとにかく金運が悪いために、土地や家財を売らなければならなかったり、母親の病気や父親のことで出費があったりします。家計に余裕がないために、誘いを断ることになり、その結果つき合いが悪いとか、ケチだとか非難されやすいでしょう。まじめに働きすぎて体調を崩しやすいときです。'
            },
            '偏官': {
                strong: '思い切った転換をはかって成果が上がるときです。人から見ると荒っぽいやり方ですが、功を奏します。会社員は、難題を任されますが、それを巧みに処理して昇進します。権力も握るでしょう。優良企業から引き抜きがあるかもしれません。自営業の人は思い切った事業転換をし、新規事業に参入して成果を上げます。規模の大きい会社から引き抜き要請があることも。才能が試されるときなので、自分には高すぎる目標でも頑張り抜きましょう。試験などではよい成績で合格するでしょう。金銭的には、異動、転職、転業のためにお金が出ますが、次のステップのための出費であり無駄にはなりません。',
                weak: '急に自分を試してみたくなって、大胆な行動をしたり、いちかばちかの勝負に出て失敗しやすいときです。変化の激しいときではありますが、自分から動くとかえって苦労がふえます。会社員は部署が変わるなどして、慣れない仕事のために苦労します。自営業の人は、内容を変えたり、店じまいせざるを得なくなったりします。仕事のストレスが大きいために、精神不安になりやすく、安眠できないこともあります。訴訟や法的な問題が起きた場合は勝つ見込みは少なく、そのために立場も名誉も失ってしまうでしょう。このようなときは、下手に動かず、趣味に興じたり、旅行などで気分転換をしたりするとよいでしょう。'
            },
            '正官': {
                strong: '社会的立場の高い人から引き立てを受けるときです。競争に勝って社会的に高い地位が得られることで自信がついてきます。それまでしてきた努力が社会的な形で実を結びます。そのことで周囲からも高い評価を受けるでしょう。会社員は、昇級や出世が期待できます。今よりも待遇のよいところへの栄転や引き抜きもあるでしょう。自営業の人は、協業や業務提携の話がまとまります。金銭的にも順調です。社会的な信用がありますから、土地や住宅の購入、あるいは事業プランのための資金作りの好機です。訴訟や法的な問題が起きた場合は有利に運び、かえって信用や評価を高めることになるでしょう。',
                weak: '周囲から期待が寄せられて、精神的な重圧に苦みます。会社員は、新しい職場でなかなか仕事が覚えられないといった苦労が多く、緊張とストレスから体調を崩しがちです。自営業の人は、古いスタイルに固執して、社会の変化にうまく対応していけず流行に乗れません。試験はレベルを落とさないと合格できません。この時期に発展を望んで無理に何かをしようとすると、信用も地位もなくしてしまいます。グループや組織ぐるみで何かを計画しても計画倒れになりやすいでしょう。いずれにせよ結果はよくないので、新しい事業は控えましょう。保証人になるのも避けたほうがよく、法的な問題になったり訴訟を起こされたりする可能性もあります。'
            },
            '偏印': {
                weak: '直観が冴えます。精神的な悟りに目覚めるときです。今まで理解できなかったことも、突然、気づきに至るでしょう。お金や物質があふれた現実的な世界よりも精神世界に興味を持つときです。それがきっかけで、透徹した境地に至ったり、優れた芸術作品や新しいプランを思いついたりします。仕事上でも変化があります。趣味が利益を生んだり、副業を持ったりと、芸術や工芸などから思いがけない喜びを得られます。引っ越しや旅をすると、何らかの有益なインスピレーションを得られるでしょう。また、年長者や先生からの大切な教えや助力を受けられます。',
                strong: '失恋や失敗などがきっかけで挫折します。鬱々とした気分になり、積極的に何かをしようとする気持ちを失います。自分の世界に閉じこもって、周囲と関わり合いを持たなくなり、親しい人と会うのさえわずらわしくなります。何をやっても続かず、中途半端になって途中で投げ出してしまいます。友達もできず、内向的になり、孤独に家にいることが多くなりがちです。この時期は会社を辞めたり学校を退学したりと、生活が大きく変わるでしょう。判断力に欠けているので、衝動的に何かをやって人にだまされたり、利用されたりして、とかく失敗しがちですから注意が必要です。'
            },
            '印綬': {
                weak: 'これまで堅実に努力してきたことが実を結び、何かで表彰されたり、名誉なことがあったりします。頭が冴えて、吸収力が増しますから、たくさんの教養を身につけることができます。学問や研究に没頭すると、とても成果が上がります。専門分野の知識をさらに学ぶには最適なときです。また、この時期は宗教や哲学に触れることにより、内面の豊かさを得ます。多くの知識を得ることで、視野が広くなり、世界情勢や経済の動向についても詳しくなるでしょう。教師、年長者、母親などからの教えや助けが得られ、何事もうまく運ぶときです。',
                strong: '内向的になり、活動力が低下するときです。母親や年長者の干渉が強くなるので、依頼心を起こしてやる気を失います。表現力は乏しくなり、気苦労が多くなります。何かの思想に夢中になったり、一つの考え方に偏ったりして、多様な考えを受け入れられなくなりがちです。社交性もなくなります。場合によっては、現実世界から身を引く人もいます。毎日、家でゴロゴロしていて、何もしたくなくなり、無気力になります。金銭的にも不調なときですから、努めてコツコツ働くのがよいでしょう。心因性の病気にかかりやすいでしょう。積極的に行動し、多くの人に会うと気が晴れます。'
            }
        };


        const hiddenStemsPriority = {
            '子': ['癸', '壬'],   '丑': ['己', '辛', '癸'],   '寅': ['甲', '丙', '戊'],
            '卯': ['乙', '甲'],   '辰': ['戊', '乙', '癸'],   '巳': ['丙', '庚', '戊'],
            '午': ['丁', '己'],   '未': ['己', '丁', '乙'],   '申': ['庚', '壬', '戊'],
            '酉': ['辛', '庚'],   '戌': ['戊', '辛', '丁'],   '亥': ['壬', '甲']
        };
        
        const shinsenhyo = {
            '寅': [{days: 7, stem: '甲'}, {days: 9, stem: '丙'}, {days: 31, stem: '戊'}],
            '卯': [{days: 10, stem: '甲'}, {days: 31, stem: '乙'}],
            '辰': [{days: 9, stem: '乙'}, {days: 12, stem: '癸'}, {days: 31, stem: '戊'}],
            '巳': [{days: 9, stem: '丙'}, {days: 12, stem: '庚'}, {days: 31, stem: '戊'}],
            '午': [{days: 10, stem: '丙'}, {days: 31, stem: '丁'}],
            '未': [{days: 9, stem: '丁'}, {days: 12, stem: '乙'}, {days: 31, stem: '己'}],
            '申': [{days: 10, stem: '庚'}, {days: 13, stem: '壬'}, {days: 31, stem: '戊'}],
            '酉': [{days: 10, stem: '庚'}, {days: 31, stem: '辛'}],
            '戌': [{days: 9, stem: '辛'}, {days: 12, stem: '丁'}, {days: 31, stem: '戊'}],
            '亥': [{days: 10, stem: '戊'}, {days: 31, stem: '甲'}],
            '子': [{days: 10, stem: '壬'}, {days: 31, stem: '癸'}],
            '丑': [{days: 9, stem: '癸'}, {days: 12, stem: '辛'}, {days: 31, stem: '己'}]
        };

        function getSixtyPillar(index) {
            return { stem: heavenlyStems[index % 10], branch: earthlyBranches[index % 12] };
        }

        function getSetsuiriDate(year, month) {
            const setsuiriConstants = {
                1:  { name: '小寒', C: 5.4055, zodiac: '丑' }, 2:  { name: '立春', C: 4.15,   zodiac: '寅' },
                3:  { name: '啓蟄', C: 5.63,   zodiac: '卯' }, 4:  { name: '清明', C: 4.9,    zodiac: '辰' },
                5:  { name: '立夏', C: 5.52,   zodiac: '巳' }, 6:  { name: '芒種', C: 5.8,    zodiac: '午' },
                7:  { name: '小暑', C: 7.1,    zodiac: '未' }, 8:  { name: '立秋', C: 7.5,    zodiac: '申' },
                9:  { name: '白露', C: 7.8,    zodiac: '酉' }, 10: { name: '寒露', C: 8.3,   zodiac: '戌' },
                11: { name: '立冬', C: 7.5,   zodiac: '亥' }, 12: { name: '大雪', C: 7.18,  zodiac: '子' }
            };
            const termData = setsuiriConstants[month];
            if (!termData) return null;
            const day = Math.floor(termData.C + 0.2422 * (year - 1900) - Math.floor((year - 1900) / 4));
            return { day: day, zodiac: termData.zodiac, name: termData.name };
        }

        function getMonthPillar(year, month, day, yearStem) {
            let targetMonth = month, targetYear = year;
            let setsuiri = getSetsuiriDate(targetYear, targetMonth);
            if (day < setsuiri.day) {
                targetMonth = month === 1 ? 12 : month - 1;
                if (month === 1) targetYear--;
                setsuiri = getSetsuiriDate(targetYear, targetMonth);
            }
            const monthBranch = setsuiri.zodiac;
            const yearStemIndex = heavenlyStems.indexOf(yearStem);
            const firstMonthStemIndexMap = [2, 4, 6, 8, 0];
            const firstMonthStemIndex = firstMonthStemIndexMap[yearStemIndex % 5];
            const toraMonthIndex = 2;
            const monthBranchIndex = earthlyBranches.indexOf(monthBranch);
            let monthOffset = monthBranchIndex - toraMonthIndex;
            if (monthOffset < 0) monthOffset += 12;
            const monthStemIndex = (firstMonthStemIndex + monthOffset) % 10;
            const monthStem = heavenlyStems[monthStemIndex];
            return { stem: monthStem, branch: monthBranch };
        }

        function getTenGod(dayStem, targetStem) {
            if (!dayStem || !targetStem) return '';
            const dayIndex = heavenlyStems.indexOf(dayStem);
            const targetIndex = heavenlyStems.indexOf(targetStem);
            if(dayIndex === -1 || targetIndex === -1) return '';
            const dayElement = stemElements[dayStem];
            const targetElement = stemElements[targetStem];
            const dayYinYang = stemYinYang[dayStem];
            const targetYinYang = stemYinYang[targetStem];
            if (dayElement === targetElement) return dayYinYang === targetYinYang ? '比肩' : '劫財';
            const elementCycle = ['木', '火', '土', '金', '水'];
            const dayElementIndex = elementCycle.indexOf(dayElement);
            const targetElementIndex = elementCycle.indexOf(targetElement);
            if ((dayElementIndex + 1) % 5 === targetElementIndex) return dayYinYang === targetYinYang ? '食神' : '傷官';
            if ((dayElementIndex + 2) % 5 === targetElementIndex) return dayYinYang !== targetYinYang ? '正財' : '偏財';
            if ((dayElementIndex + 3) % 5 === targetElementIndex) return dayYinYang !== targetYinYang ? '正官' : '偏官';
            if ((dayElementIndex + 4) % 5 === targetElementIndex) return dayYinYang !== targetYinYang ? '印綬' : '偏印';
            return '';
        }

        function getTwelveStage(stem, branch) {
            const stemIndex = heavenlyStems.indexOf(stem);
            const branchIndex = earthlyBranches.indexOf(branch);
            if(stemIndex === -1 || branchIndex === -1) return '';
            const element = stemElements[stem];
            const stageMap = {
                '木': [11, 6, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9], '火': [2, 9, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0],
                '土': [5, 0, 6, 7, 8, 9, 10, 11, 0, 1, 2, 3], '金': [8, 3, 9, 10, 11, 0, 1, 2, 3, 4, 5, 6],
                '水': [11, 6, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
            };
            const stageIndex = stageMap[element][branchIndex];
            return twelveStages[stageIndex];
        }

        function initializeSelects() {
            document.querySelectorAll('.stem-select').forEach(select => {
                select.innerHTML = '<option value="">-</option>';
                heavenlyStems.forEach(stem => select.add(new Option(stem, stem)));
            });
            document.querySelectorAll('.branch-select').forEach(select => {
                select.innerHTML = '<option value="">-</option>';
                earthlyBranches.forEach(branch => select.add(new Option(branch, branch)));
            });
        }

        window.onload = initializeSelects;

        function calculate() {
            const birthDateStr = document.getElementById('birthDate').value;
            const birthTime = document.getElementById('birthTime').value;
            window.currentBirthDate = new Date(`${birthDateStr}T${birthTime}`);

            const year = window.currentBirthDate.getFullYear(), month = window.currentBirthDate.getMonth() + 1, day = window.currentBirthDate.getDate();
            document.getElementById('nenunStartYear').value = year;

            const risshun = getSetsuiriDate(year, 2);
            const risshunDate = new Date(year, 1, risshun.day);
            const astrologicalYear = window.currentBirthDate < risshunDate ? year - 1 : year;
            const yearPillar = getSixtyPillar((astrologicalYear - 1864) % 60);
            const monthPillar = getMonthPillar(year, month, day, yearPillar.stem);
            const baseDate = new Date(1900, 0, 1);
            const daysDiff = Math.floor((window.currentBirthDate - baseDate) / (1000 * 60 * 60 * 24));
            const dayPillar = getSixtyPillar((daysDiff + 10) % 60);
            
            const [hour, minute] = birthTime.split(':').map(Number);
            const hourBranchIndex = Math.floor((hour + 1) / 2) % 12;
            const hourBranch = earthlyBranches[hourBranchIndex];
            const dayStemIndex = heavenlyStems.indexOf(dayPillar.stem);
            const hourStemIndex = ((dayStemIndex % 5) * 2 + hourBranchIndex) % 10;
            const hourStem = heavenlyStems[hourStemIndex];

            document.getElementById('yearStem').value = yearPillar.stem;
            document.getElementById('yearBranch').value = yearPillar.branch;
            document.getElementById('monthStem').value = monthPillar.stem;
            document.getElementById('monthBranch').value = monthPillar.branch;
            document.getElementById('dayStem').value = dayPillar.stem;
            document.getElementById('dayBranch').value = dayPillar.branch;
            document.getElementById('hourStem').value = hourStem;
            document.getElementById('hourBranch').value = hourBranch;

            window.currentGender = document.getElementById('gender').value;
            
            updateAnalysis();
            document.getElementById('resultSection').style.display = 'block';
        }

        // --- Start of Kango/Shigo Logic ---
        
        const isKangoPair = (s1, s2) => {
            const pairs = [['甲', '己'], ['乙', '庚'], ['丙', '辛'], ['丁', '壬'], ['戊', '癸']];
            return pairs.some(p => (p[0] === s1 && p[1] === s2) || (p[0] === s2 && p[1] === s1));
        };

        const isShichuPair = (b1, b2) => {
            const pairs = [['子', '午'], ['丑', '未'], ['寅', '申'], ['卯', '酉'], ['辰', '戌'], ['巳', '亥']];
            return pairs.some(p => (p[0] === b1 && p[1] === b2) || (p[0] === b2 && p[1] === b1));
        };

        const shigoPairs = [
            { b1: '子', b2: '丑', element: '土', requiredStems: ['戊', '己', '丙', '丁'] },
            { b1: '亥', b2: '寅', element: '木', requiredStems: ['甲', '乙', '壬', '癸'] },
            { b1: '卯', b2: '戌', element: '火', requiredStems: ['丙', '丁', '甲', '乙'] },
            { b1: '辰', b2: '酉', element: '金', requiredStems: ['庚', '辛', '戊', '己'] },
            { b1: '巳', b2: '申', element: '水', requiredStems: ['壬', '癸', '庚', '辛'] },
            { b1: '午', b2: '未', element: '火', requiredStems: ['丙', '丁', '甲', '乙'] }
        ];

        const isShigoPair = (b1, b2) => {
            return shigoPairs.some(p => (p.b1 === b1 && p.b2 === b2) || (p.b1 === b2 && p.b2 === b1));
        };

        function checkKango(originalStems, branches) {
            let transformedStems = [...originalStems];
            let messages = [];
            let kangoedIndices = new Set();
        
            const hasElement = (elementKey, chart, exclusions = []) => {
                const elementChars = elements[elementKey];
                const chartToCheck = [...chart.stems, ...chart.branches];
                for (const char of chartToCheck) {
                    if (exclusions.includes(char)) continue;
                    if (elementChars.includes(char)) {
                        return true;
                    }
                }
                return false;
            };
        
            const kangoRules = [
                { pair: ['甲', '己'], newElement: '土', newStems: { '甲': '戊', '己':'己' }, monthBranches: ['丑', '辰', '未', '戌', '巳', '午'], blockingElement: 'wood' },
                { pair: ['乙', '庚'], newElement: '金', newStems: { '乙': '辛', '庚':'庚' }, monthBranches: ['申', '酉', '丑', '辰', '未', '戌'], blockingElement: 'fire' },
                { pair: ['丙', '辛'], newElement: '水', newStems: { '丙': '壬', '辛': '癸' }, monthBranches: ['子', '亥', '申', '酉', '丑', '辰'], blockingElement: 'earth', blockingExclusion: ['丑', '辰'] },
                { pair: ['丁', '壬'], newElement: '木', newStems: { '丁': '乙', '壬': '甲' }, monthBranches: ['寅', '卯', '亥', '子', '未'], blockingElement: 'metal' },
                { pair: ['戊', '癸'], newElement: '火', newStems: { '戊': '丙', '癸': '丁' }, monthBranches: ['巳', '午', '寅', '卯', '戌', '未'], blockingElement: 'water' }
            ];
        
            const isKangoMD = isKangoPair(originalStems[1], originalStems[2]);
            const isKangoDH = isKangoPair(originalStems[2], originalStems[3]);
            if (isKangoMD && isKangoDH) {
                messages.push(`日干が月干と時干の両方から干合される妬合（とうごう）のため、干合は変化しません。`);
                return { transformedStems: originalStems, messages };
            }
        
            const checkPairs = [
                { idx1: 1, idx2: 2, name: '月干-日干' },
                { idx1: 2, idx2: 3, name: '日干-時干' },
                { idx1: 0, idx2: 1, name: '年干-月干' }
            ];
        
            for (const { idx1, idx2, name } of checkPairs) {
                if (kangoedIndices.has(idx1) || kangoedIndices.has(idx2)) {
                    continue;
                }
        
                const s1 = originalStems[idx1];
                const s2 = originalStems[idx2];
        
                if (!isKangoPair(s1, s2)) {
                    continue;
                }

                const rule = kangoRules.find(r => r.pair.includes(s1) && r.pair.includes(s2));
        
                if (rule) {
                    const monthBranch = branches[1];
                    const isMonthBranchValid = rule.monthBranches.includes(monthBranch);
                    const exclusionsForBlockingCheck = [s1, s2, ...(rule.blockingExclusion || [])];
                    const isNotBlocked = !hasElement(rule.blockingElement, { stems: originalStems, branches: branches }, exclusionsForBlockingCheck);
        
                    if (isMonthBranchValid && isNotBlocked) {
                        transformedStems[idx1] = rule.newStems[s1] || s1;
                        transformedStems[idx2] = rule.newStems[s2] || s2;
                        
                        messages.push(`${name}で${s1}${s2}干合が成立し、${rule.newElement}に変化します。`);
                        kangoedIndices.add(idx1);
                        kangoedIndices.add(idx2);
                    } else {
                        let reason = [];
                        if (!isMonthBranchValid) reason.push("月支の条件を満たしません");
                        if (!isNotBlocked) reason.push(`命式中に変化を妨げる${rule.blockingElement}の気があります`);
                        messages.push(`${name}で${s1}${s2}干合がありますが、変化しません (${reason.join('、')})。`);
                    }
                }
            }
        
            return { transformedStems, messages };
        }

        function checkShigo(stems, branches) {
            let strengthenedElement = null;
            let messages = [];
        
            const isShigoYM = isShigoPair(branches[0], branches[1]);
            const isShigoMD = isShigoPair(branches[1], branches[2]);
            const isShigoDH = isShigoPair(branches[2], branches[3]);
        
            const monthIsTogo = isShigoYM && isShigoMD;
            const dayIsTogo = isShigoMD && isShigoDH;
        
            const checks = [
                { key: 'YM', isValid: isShigoYM && !monthIsTogo, idxA: 0, idxB: 1, info: '年支-月支' },
                { key: 'MD', isValid: isShigoMD && !monthIsTogo && !dayIsTogo, idxA: 1, idxB: 2, info: '月支-日支' },
                { key: 'DH', isValid: isShigoDH && !dayIsTogo, idxA: 2, idxB: 3, info: '日支-時支' }
            ];

            if (monthIsTogo) messages.push(`月支が年支と日支に挟まれる妬合のため、年支-月支と月支-日支の支合は変化しません。`);
            if (dayIsTogo && !monthIsTogo) messages.push(`日支が月支と時支に挟まれる妬合のため、月支-日支と日支-時支の支合は変化しません。`);

            for (const check of checks) {
                if (!check.isValid) continue;
        
                const bA = branches[check.idxA], bB = branches[check.idxB];
                const sA = stems[check.idxA], sB = stems[check.idxB];
        
                const prevBranch = branches[check.idxA - 1];
                const nextBranch = branches[check.idxB + 1];
                if ((prevBranch && isShichuPair(bA, prevBranch)) || (nextBranch && isShichuPair(bB, nextBranch))) {
                    messages.push(`${check.info}で${bA}${bB}の支合がありますが、隣接する地支と支冲が成立するため変化しません。`);
                    continue;
                }
        
                if (isKangoPair(sA, sB)) {
                    messages.push(`${check.info}で${bA}${bB}の支合がありますが、天干が干合しているため変化しません。`);
                    continue;
                }
        
                const pairInfo = shigoPairs.find(p => (p.b1 === bA && p.b2 === bB) || (p.b1 === bB && p.b2 === bA));
                if (pairInfo && (pairInfo.requiredStems.includes(sA) || pairInfo.requiredStems.includes(sB))) {
                    strengthenedElement = pairInfo.element;
                    messages.push(`${check.info}で${bA}${bB}支合が成立し、${pairInfo.element}の力量が強まります。`);
                    break; 
                } else if (pairInfo) {
                     messages.push(`${check.info}で${bA}${bB}支合がありますが、変化の条件を満たさないため力量は変化しません。`);
                }
            }
        
            return { strengthenedElement, messages };
        }
        
        // --- End of Kango/Shigo Logic ---


        function updateAnalysis() {
            let stemsUI = [
                document.getElementById('hourStem').value,
                document.getElementById('dayStem').value,
                document.getElementById('monthStem').value,
                document.getElementById('yearStem').value
            ];
            let branchesUI = [
                document.getElementById('hourBranch').value,
                document.getElementById('dayBranch').value,
                document.getElementById('monthBranch').value,
                document.getElementById('yearBranch').value
            ];
            
            if (stemsUI.includes('') || branchesUI.includes('')) return;
            
            const sortedStems = [stemsUI[3], stemsUI[2], stemsUI[1], stemsUI[0]];
            const sortedBranches = [branchesUI[3], branchesUI[2], branchesUI[1], branchesUI[0]];

            const kangoResult = checkKango(sortedStems, sortedBranches);
            let transformedStems = kangoResult.transformedStems;
            const shigoResult = checkShigo(transformedStems, sortedBranches);

            const yearStemUI = document.getElementById('yearStem');
            const monthStemUI = document.getElementById('monthStem');
            const dayStemUI = document.getElementById('dayStem');
            const hourStemUI = document.getElementById('hourStem');
            
            const displayStems = [transformedStems[3], transformedStems[2], transformedStems[1], transformedStems[0]];
            const originalDisplayStems = [sortedStems[3], sortedStems[2], sortedStems[1], sortedStems[0]];
            
            [hourStemUI, dayStemUI, monthStemUI, yearStemUI].forEach((ui, index) => {
                ui.value = displayStems[index];
                if (displayStems[index] !== originalDisplayStems[index]) {
                    ui.classList.add('transformed');
                } else {
                    ui.classList.remove('transformed');
                }
            });

            const dayStem = transformedStems[2];
            if (!dayStem) return;

            document.getElementById('hourHidden').textContent = hiddenStemsPriority[sortedBranches[3]]?.join('・') || '';
            document.getElementById('dayHidden').textContent = hiddenStemsPriority[sortedBranches[2]]?.join('・') || '';
            document.getElementById('monthHidden').textContent = hiddenStemsPriority[sortedBranches[1]]?.join('・') || '';
            document.getElementById('yearHidden').textContent = hiddenStemsPriority[sortedBranches[0]]?.join('・') || '';

            const hiddenGods = [sortedBranches[3], sortedBranches[2], sortedBranches[1], sortedBranches[0]].map(branch => {
                const hidden = hiddenStemsPriority[branch];
                return hidden ? hidden.map(hStem => getTenGod(dayStem, hStem)).join('・') : '';
            });
            document.getElementById('hourHiddenGod').textContent = hiddenGods[0];
            document.getElementById('dayHiddenGod').textContent = hiddenGods[1];
            document.getElementById('monthHiddenGod').textContent = hiddenGods[2];
            document.getElementById('yearHiddenGod').textContent = hiddenGods[3];


            document.getElementById('hourGod').textContent = getTenGod(dayStem, transformedStems[3]);
            document.getElementById('monthGod').textContent = getTenGod(dayStem, transformedStems[1]);
            document.getElementById('yearGod').textContent = getTenGod(dayStem, transformedStems[0]);
            
            // 十二運の計算と表示をコメントアウト
            // document.getElementById('hour12').textContent = getTwelveStage(dayStem, sortedBranches[3]);
            // document.getElementById('day12').textContent = getTwelveStage(dayStem, sortedBranches[2]);
            // document.getElementById('month12').textContent = getTwelveStage(dayStem, sortedBranches[1]);
            // document.getElementById('year12').textContent = getTwelveStage(dayStem, sortedBranches[0]);
            
            const strength = analyzeDestiny(dayStem, transformedStems, sortedBranches, kangoResult.messages, shigoResult);
            
            if (window.currentGender && window.currentBirthDate) {
                calculateDaiunn(dayStem, strength);
                calculateNenun(dayStem, strength);
            }
        }
        
        function getSpecialKakkyoku(strengthResult, dayStem, stems, branches) {
            const allStemsForGods = [];
            allStemsForGods.push(stems[0], stems[1], stems[3]); 
            
            branches.forEach(b => {
                if (hiddenStemsPriority[b]) {
                    allStemsForGods.push(...hiddenStemsPriority[b]);
                }
            });

            const tenGods = allStemsForGods.map(s => getTenGod(dayStem, s)).filter(g => g);

            if (strengthResult.includes('極身強')) {
                const juoCount = tenGods.filter(g => g === '比肩' || g === '劫財').length;
                const jukyoCount = tenGods.filter(g => g === '偏印' || g === '印綬').length;

                if (juoCount >= jukyoCount) {
                    return '従旺格';
                } else {
                    return '従強格';
                }
            }

            if (strengthResult.includes('極身弱')) {
                const jujiCount = tenGods.filter(g => g === '食神' || g === '傷官').length;
                const juzaiCount = tenGods.filter(g => g === '偏財' || g === '正財').length;
                const jusatsuCount = tenGods.filter(g => g === '偏官' || g === '正官').length;
                
                if (jujiCount > 0 && juzaiCount > 0 && jusatsuCount > 0) {
                     return '従勢格';
                }

                const maxCount = Math.max(jujiCount, juzaiCount, jusatsuCount);
                if (maxCount === 0) return '特別格局（分類不能）';
                if (maxCount === jujiCount) return '従児格';
                if (maxCount === juzaiCount) return '従財格';
                if (maxCount === jusatsuCount) return '従殺格';
            }
            
            return '特別格局（判定不能）';
        }

        function getNormalKakkyoku(dayStem, stems, branches, birthDate) {
            const yearStem = stems[0], monthStem = stems[1], hourStem = stems[3];
            const monthBranch = branches[1];

            const kenrokuConditions = { '甲': '寅', '乙': '卯', '丙': '巳', '丁': '午', '戊': '巳', '己': '午', '庚': '申', '辛': '酉', '壬': '亥', '癸': '子' };
            if (kenrokuConditions[dayStem] === monthBranch) return '建禄格';
            const getsurinConditions = { '甲': '卯', '丙': '午', '戊': '午', '庚': '酉', '壬': '子' };
            if (getsurinConditions[dayStem] === monthBranch) return '月刃格';

            const monthHiddenStems = hiddenStemsPriority[monthBranch];
            if (!monthHiddenStems) return '判定不能';

            const getElement = (stem) => stem ? stemElements[stem] : null;
            
            const findKakkyokuFromHidden = (hiddenStem) => {
                const god = getTenGod(dayStem, hiddenStem);
                if (god === '比肩') return '建禄格';
                if (god === '劫財') return '月刃格';
                return god ? god + '格' : '判定不能';
            };

            if (monthStem) {
                for (const hidden of monthHiddenStems) {
                    if (getElement(hidden) === getElement(monthStem)) return findKakkyokuFromHidden(hidden);
                }
            }
            
            let foundInYearHour = null;
            for (const hidden of monthHiddenStems) {
                 if ((yearStem && getElement(hidden) === getElement(yearStem)) || (hourStem && getElement(hidden) === getElement(hourStem))) {
                    foundInYearHour = hidden;
                    break;
                 }
            }
            if(foundInYearHour) return findKakkyokuFromHidden(foundInYearHour);
            
            const year = birthDate.getFullYear(), month = birthDate.getMonth() + 1, day = birthDate.getDate();
            let astroYear = year, astroMonth = month;
            let currentSetsuiri = getSetsuiriDate(astroYear, astroMonth);
            
            if(day < currentSetsuiri.day) {
                astroMonth = month === 1 ? 12 : month - 1;
                if (month === 1) astroYear--;
                currentSetsuiri = getSetsuiriDate(astroYear, astroMonth);
            }
            
            const daysPassed = day - currentSetsuiri.day + 1;
            const shinsenhyoRules = shinsenhyo[monthBranch];
            
            if(shinsenhyoRules){
                for(const rule of shinsenhyoRules){
                    if(daysPassed <= rule.days){
                        const chosenStem = rule.stem;
                        return findKakkyokuFromHidden(chosenStem);
                    }
                }
            }

            return '判定不能';
        }

        function analyzeDestiny(dayStem, stems, branches, kangoMessages, shigoResult) {
            const elementCount = {'木': 0, '火': 0, '土': 0, '金': 0, '水': 0};
            stems.forEach(stem => {
                if (stem) elementCount[stemElements[stem]]++;
            });
            branches.forEach(branch => {
                if (branch) elementCount[branchElements[branch]]++;
            });

            if (shigoResult.strengthenedElement) {
                elementCount[shigoResult.strengthenedElement] += 2;
            }

            const dayElement = stemElements[dayStem];
            const dayYinYang = stemYinYang[dayStem];
            const strength = judgeStrength(dayStem, stems, branches);
            
            let kakkyoku;
            if (strength.includes('極身強') || strength.includes('極身弱')) {
                kakkyoku = getSpecialKakkyoku(strength, dayStem, stems, branches);
            } else {
                kakkyoku = getNormalKakkyoku(dayStem, stems, branches, window.currentBirthDate);
            }
            
            const kakkyokuInfo = kakkyokuDescriptions[kakkyoku] || { title: '判定不能', description: 'あなたの価値観の源となる格局を特定できませんでした。' };

            // Start: Added logic for counting Tsuhensei
            const tsuhenseiList = [];
            // Tenkan (Heavenly Stems)
            tsuhenseiList.push(getTenGod(dayStem, stems[0])); // Year
            tsuhenseiList.push(getTenGod(dayStem, stems[1])); // Month
            tsuhenseiList.push(getTenGod(dayStem, stems[3])); // Hour

            // Zokan Honki (Main Hidden Stems)
            tsuhenseiList.push(getTenGod(dayStem, hiddenStemsPriority[branches[0]]?.[0])); // Year
            tsuhenseiList.push(getTenGod(dayStem, hiddenStemsPriority[branches[1]]?.[0])); // Month
            tsuhenseiList.push(getTenGod(dayStem, hiddenStemsPriority[branches[2]]?.[0])); // Day
            tsuhenseiList.push(getTenGod(dayStem, hiddenStemsPriority[branches[3]]?.[0])); // Hour

            const tsuhenseiCounts = tsuhenseiList.reduce((acc, god) => {
                if (god) {
                    acc[god] = (acc[god] || 0) + 1;
                }
                return acc;
            }, {});

            let tsuhenseiCountHTML = '';
            const orderedGods = ['比肩', '劫財', '食神', '傷官', '偏財', '正財', '偏官', '正官', '偏印', '印綬'];
            const parts = orderedGods.map(god => {
                const count = tsuhenseiCounts[god] || 0;
                return count > 0 ? `<strong>${god}:</strong> ${count}個` : '';
            }).filter(part => part !== '');

            if (parts.length > 0) {
                tsuhenseiCountHTML = `
                    <div class="analysis-item">
                        <div class="analysis-title">通変星の数（天干と蔵干本気）</div>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 8px; margin-top: 10px;">
                            ${parts.map(p => `<div style="padding: 8px; background: #f0f2f5; border-radius: 4px; text-align: center;">${p}</div>`).join('')}
                        </div>
                    </div>
                `;
            }
            // End: Added logic

            let transformationHTML = '';
            const allMessages = [...kangoMessages, ...shigoResult.messages].filter((v, i, a) => a.indexOf(v) === i); 
            if (allMessages.length > 0) {
                transformationHTML += `<div class="analysis-item">
                    <div class="analysis-title">命式の変化</div>`;
                 allMessages.forEach(msg => {
                    const type = msg.includes("干合") ? "【干合】" : "【支合】";
                    transformationHTML += `<div><span class="transformed">${type}</span>${msg}</div>`;
                 });
                transformationHTML += `</div>`;
            }

            let analysisHTML = transformationHTML + `
                <div class="analysis-item">
                    <div class="analysis-title">日主（あなたの本質）</div>
                    <div>${dayStem}（${dayYinYang}の${dayElement}）</div>
                    <div>${getDayStemDescription(dayStem)}</div>
                </div>
                 <div class="analysis-item">
                    <div class="analysis-title">格局（あなたの価値観）</div>
                    <div><strong>${kakkyoku}</strong>：${kakkyokuInfo.title}</div>
                    <div style="margin-top: 8px; line-height: 1.6;">${kakkyokuInfo.description}</div>
                </div>
                <div class="analysis-item">
                    <div class="analysis-title">五行バランス</div>
                    <div class="element-balance">
                        <div class="element-bar wood">木: ${elementCount['木']}</div>
                        <div class="element-bar fire">火: ${elementCount['火']}</div>
                        <div class="element-bar earth">土: ${elementCount['土']}</div>
                        <div class="element-bar metal">金: ${elementCount['金']}</div>
                        <div class="element-bar water">水: ${elementCount['水']}</div>
                    </div>
                </div>
                <div class="analysis-item">
                    <div class="analysis-title">身強・身弱判定</div>
                    <div>${strength}</div>
                </div>
                ${tsuhenseiCountHTML}
                <div class="analysis-item">
                    <div class="analysis-title">総合運勢</div>
                    <div style="line-height: 1.6;">${getOverallFortune(dayStem, strength, elementCount)}</div>
                </div>`;
            document.getElementById('analysisResult').innerHTML = analysisHTML;
            return strength;
        }
        
        function judgeStrength(dayStem, stems, branches) {
            if (!dayStem || branches.some(b => !b) || stems.some(s => !s)) {
                return '命式が不完全なため判定できません。';
            }
        
            const elementCycle = ['木', '火', '土', '金', '水'];
            const getElement = (name) => {
                const stemEl = stemElements[name];
                if (stemEl) return stemEl;
                const branchEl = branchElements[name];
                if (branchEl) return branchEl;
                return null;
            };
        
            const dayElement = getElement(dayStem);
            const monthBranch = branches[1];
        
            const getRelationship = (baseEl, targetEl) => {
                if (!baseEl || !targetEl) return 'none';
                if (baseEl === targetEl) return 'same'; 
                
                const baseIndex = elementCycle.indexOf(baseEl);
                const targetIndex = elementCycle.indexOf(targetEl);

                if ((baseIndex + 4) % 5 === targetIndex) return 'produced_by'; 
                if ((baseIndex + 1) % 5 === targetIndex) return 'produces'; 
                if ((baseIndex + 2) % 5 === targetIndex) return 'attacks';
                if ((baseIndex + 3) % 5 === targetIndex) return 'attacked_by';
                return 'none';
            };
        
            const isStrengthening = (relationship) => ['same', 'produced_by'].includes(relationship);
            const isWeakening = (relationship) => ['produces', 'attacks', 'attacked_by'].includes(relationship);
        
            const isTokurei = isStrengthening(getRelationship(dayElement, getElement(monthBranch)));
            const isShitsurei = isWeakening(getRelationship(dayElement, getElement(monthBranch)));
        
            const strengtheningBranchesCount = [branches[0], branches[2], branches[3]]
                .filter(b => isStrengthening(getRelationship(dayElement, getElement(b)))).length;
            const hasTokuchi = strengtheningBranchesCount > 0;
        
            const strengtheningStemsCount = [stems[0], stems[1], stems[3]]
                .filter(s => isStrengthening(getRelationship(dayElement, getElement(s)))).length;
            const hasTokujo = strengtheningStemsCount > 0;
        
            const checkKaikyoku = () => {
                const branchSet = new Set(branches);
                const combinations = [
                    { name: '三方木局', branches: ['寅', '卯', '辰'], element: '木' }, { name: '三方火局', branches: ['巳', '午', '未'], element: '火' },
                    { name: '三方金局', branches: ['申', '酉', '戌'], element: '金' }, { name: '三方水局', branches: ['亥', '子', '丑'], element: '水' },
                    { name: '三合木局', branches: ['亥', '卯', '未'], element: '木' }, { name: '三合火局', branches: ['寅', '午', '戌'], element: '火' },
                    { name: '三合金局', branches: ['巳', '酉', '丑'], element: '金' }, { name: '三合水局', branches: ['申', '子', '辰'], element: '水' },
                ];
                for (const comb of combinations) {
                    if (comb.branches.every(b => branchSet.has(b))) {
                        if (isStrengthening(getRelationship(dayElement, comb.element))) {
                            return { found: true, includesMonthBranch: comb.branches.includes(monthBranch) };
                        }
                    }
                }
                return { found: false, includesMonthBranch: false };
            };
            const kaikyokuResult = checkKaikyoku();
        
            if (isTokurei && strengtheningStemsCount >= 2 && strengtheningBranchesCount >= 2) {
                return '極身強：日主の力が極めて強く、非常に大きなエネルギーを持っています。自己の意志を貫く強さがありますが、強引になりすぎないよう周囲との調和を意識することが成功の鍵です。';
            }
        
            const weakeningStemsCount = [stems[0], stems[1], stems[3]]
                .filter(s => isWeakening(getRelationship(dayElement, getElement(s)))).length;
            const allWeakeningBranchesCount = branches
                .filter(b => isWeakening(getRelationship(dayElement, getElement(b)))).length;
        
            if (isShitsurei && weakeningStemsCount >= 2 && allWeakeningBranchesCount >= 3) {
                 return '極身弱：日主の力が極めて弱く、繊細で周囲の影響を受けやすいです。自分を支えてくれる環境や人間関係を何よりも大切に。無理をせず、自分のペースで着実に進むことで才能が開花します。';
            }
        
            let isMikyo = false;
            const conditionsMet = [isTokurei, hasTokuchi, hasTokujo];
            const conditionsMetCount = conditionsMet.filter(Boolean).length;
        
            if (conditionsMetCount >= 2) {
                if (!conditionsMet[0] && conditionsMet[1] && conditionsMet[2]) {
                    if (strengtheningBranchesCount + strengtheningStemsCount >= 3) isMikyo = true;
                } else {
                    isMikyo = true;
                }
            }
        
            if (!isMikyo && kaikyokuResult.found) {
                if (kaikyokuResult.includesMonthBranch || (!kaikyokuResult.includesMonthBranch && isTokurei)) {
                    isMikyo = true;
                }
            }
        
            if (isMikyo) {
                return '身強：日主の力が強く、行動力と自己肯定感が高いタイプです。リーダーシップを発揮できますが、時には他者の意見に耳を傾ける柔軟性も持つことで、より大きな成功を掴めます。';
            }
        
            return '身弱：協調性があり、周囲の状況に合わせて柔軟に対応できるタイプです。サポート役やチームで動くことで力を発揮します。自信を持ち、信頼できる仲間との連携を大切にしましょう。';
        }

        function getDayStemDescription(stem) {
            const descriptions = {
                '甲': '大樹のような存在感があり、リーダーシップに優れています。正直で真っ直ぐな性格です。', '乙': '草花のような柔軟性があり、協調性に富んでいます。繊細で美的感覚に優れています。',
                '丙': '太陽のような明るさがあり、情熱的で行動力があります。人を惹きつける魅力があります。', '丁': 'ろうそくの火のような優しい光で、周囲を温かく照らします。思慮深く献身的です。',
                '戊': '山のようにどっしりとした安定感があり、信頼される存在です。包容力があります。', '己': '大地のような母性的な優しさがあり、育む力に優れています。堅実で真面目です。',
                '庚': '刀剣のような鋭さがあり、決断力と実行力に優れています。正義感が強いです。', '辛': '宝石のような繊細さと美しさがあり、センスと感性に優れています。完璧主義的です。',
                '壬': '大海のような包容力があり、知識欲旺盛で適応力があります。自由を愛します。', '癸': '雨露のような潤いを与える存在で、知恵と直感力に優れています。神秘的な魅力があります。'
            };
            return descriptions[stem] || '';
        }

        function getOverallFortune(dayStem, strength, elementCount) {
            let fortune = `あなたは${dayStem}の生まれで、${stemElements[dayStem]}の性質を持っています。`;
            if (strength.includes('極身強')) fortune += '非常に強いエネルギーと実行力を持ち、困難な状況でも突破できる力があります。その強大な力を社会貢献や創造的な活動に向けることで、大きな成功を収められるでしょう。謙虚さと柔軟性を忘れずに、周囲との調和を保つことが長期的な成功の鍵となります。';
            else if (strength.includes('身強')) fortune += '強い個性と実行力を持っているため、リーダーシップを発揮する場面で活躍できるでしょう。時には周囲の意見に耳を傾け、柔軟性を持つことでさらなる成長が期待できます。';
            else if (strength.includes('身弱')) fortune += '協調性と適応力に優れ、チームワークを大切にすることで成功を収められるでしょう。自分を支えてくれる人間関係を大切にし、自信を持って行動することが開運の鍵となります。';
            else if (strength.includes('極身弱')) fortune += '繊細な感受性と洞察力を持ち、人の気持ちを理解する能力に優れています。サポーター的な立場で力を発揮し、協力的な環境で才能が開花します。無理をせず自分のペースを大切にし、信頼できる仲間と共に歩むことで幸運を引き寄せられるでしょう。';
            
            const minElement = Object.keys(elementCount).reduce((a, b) => elementCount[a] < elementCount[b] ? a : b);
            const elementAdvice = {
                '木': '緑色のものを身につけたり、観葉植物を育てることで運気が上昇します。', '火': '赤色のアイテムを取り入れたり、太陽の光を浴びることで活力が増します。',
                '土': '黄色や茶色を意識し、大地に触れる機会を増やすと安定感が増します。', '金': '白色や金属製のアクセサリーを身につけることで決断力が高まります。',
                '水': '青色や黒色を取り入れ、水辺で過ごす時間を作ると知恵が深まります。'
            };
            fortune += `<br><br><strong>【開運アドバイス】</strong><br>${elementAdvice[minElement]}`;
            return fortune;
        }

        function calculateDaiunn(dayStem, strength) {
            const yearStem = document.getElementById('yearStem').value;
            const monthStem = document.getElementById('monthStem').value;
            const monthBranch = document.getElementById('monthBranch').value;
            if (!yearStem || !monthStem || !monthBranch || !window.currentGender || !window.currentBirthDate || !strength) return;

            const gender = window.currentGender;
            const birthDateWithTime = window.currentBirthDate;
            const yearStemIndex = heavenlyStems.indexOf(yearStem);
            const isYangYear = yearStemIndex % 2 === 0;
            const isForward = (isYangYear && gender === 'male') || (!isYangYear && gender === 'female');

            const year = birthDateWithTime.getFullYear(), month = birthDateWithTime.getMonth() + 1;
            let daysDiff = 0;
            let setsuiriDateForCalc;

            if (isForward) {
                const currentMonthSetsuiri = getSetsuiriDate(year, month);
                if (birthDateWithTime.getDate() >= currentMonthSetsuiri.day) {
                    const nextMonth = month === 12 ? 1 : month + 1;
                    const nextYear = month === 12 ? year + 1 : year;
                    const nextSetsuiri = getSetsuiriDate(nextYear, nextMonth);
                    setsuiriDateForCalc = new Date(nextYear, nextMonth - 1, nextSetsuiri.day);
                } else {
                    setsuiriDateForCalc = new Date(year, month - 1, currentMonthSetsuiri.day);
                }
                daysDiff = (setsuiriDateForCalc.getTime() - birthDateWithTime.getTime()) / (1000 * 60 * 60 * 24);
            } else {
                const currentMonthSetsuiri = getSetsuiriDate(year, month);
                if (birthDateWithTime.getDate() < currentMonthSetsuiri.day) {
                    const prevMonth = month === 1 ? 12 : month - 1;
                    const prevYear = month === 1 ? year - 1 : year;
                    const prevSetsuiri = getSetsuiriDate(prevYear, prevMonth);
                    setsuiriDateForCalc = new Date(prevYear, prevMonth - 1, prevSetsuiri.day);
                } else {
                    setsuiriDateForCalc = new Date(year, month - 1, currentMonthSetsuiri.day);
                }
                daysDiff = (birthDateWithTime.getTime() - setsuiriDateForCalc.getTime()) / (1000 * 60 * 60 * 24);
            }

            const startAge = Math.max(1, Math.round(daysDiff / 3));
            const monthStemIndex = heavenlyStems.indexOf(monthStem);
            const monthBranchIndex = earthlyBranches.indexOf(monthBranch);
            
            const strengthType = strength.includes('身強') || strength.includes('極身強') ? 'strong' : 'weak';

            let daiunnHTML = '<table class="daiunn-table"><tr><th>年齢</th><th>大運干支</th><th>天干通変星</th><th>地支通変星</th><th>運勢</th></tr>';
            for (let i = 0; i < 8; i++) {
                const age = startAge + (i * 10);
                const stemIndex = isForward ? (monthStemIndex + i + 1) % 10 : (monthStemIndex - i - 1 + 100) % 10;
                const branchIndex = isForward ? (monthBranchIndex + i + 1) % 12 : (monthBranchIndex - i - 1 + 120) % 12;
                const daiunnStem = heavenlyStems[stemIndex];
                const daiunnBranch = earthlyBranches[branchIndex];

                const stemGod = getTenGod(dayStem, daiunnStem);
                const mainHiddenStem = hiddenStemsPriority[daiunnBranch]?.[0];
                const branchGod = getTenGod(dayStem, mainHiddenStem);

                const stemFortune = nenunFortunes[stemGod]?.[strengthType] || '－';
                const branchFortune = nenunFortunes[branchGod]?.[strengthType] || '－';

                let fortuneHTML = '';
                if (stemGod) {
                    fortuneHTML += `<div><strong>${stemGod}の運気（表面的）:</strong><br>${stemFortune}</div>`;
                }
                if (branchGod && stemGod !== branchGod) {
                    fortuneHTML += `<div style="margin-top:8px;"><strong>${branchGod}の運気（本質的）:</strong><br>${branchFortune}</div>`;
                } else if (branchGod && stemGod === branchGod) {
                     fortuneHTML += `<div style="margin-top:8px;">(本質的にも同じ運気です)</div>`;
                }
                
                daiunnHTML += `<tr>
                    <td>${age}歳～${age+9}歳</td>
                    <td>${daiunnStem}${daiunnBranch}</td>
                    <td>${stemGod || '－'}</td>
                    <td>${branchGod || '－'}</td>
                    <td>${fortuneHTML}</td>
                </tr>`;
            }
            daiunnHTML += '</table>';

            document.getElementById('daiunnResult').innerHTML = daiunnHTML;
            document.getElementById('daiunnSection').style.display = 'block';
        }


        function calculateNenun(dayStem, strength) {
            const startYear = parseInt(document.getElementById('nenunStartYear').value) || new Date().getFullYear();
            if (!dayStem || !strength) return;

            const strengthType = strength.includes('身強') || strength.includes('極身強') ? 'strong' : 'weak';

            let nenunHTML = '<table class="nenun-table"><tr><th>年</th><th>年干支</th><th>天干通変星</th><th>地支通変星</th><th>運勢</th></tr>';
            for (let i = 0; i < 10; i++) {
                const year = startYear + i;
                const yearPillar = getSixtyPillar((year - 1864) % 60);

                const stemGod = getTenGod(dayStem, yearPillar.stem);
                
                // Get branch god from main hidden stem
                const mainHiddenStem = hiddenStemsPriority[yearPillar.branch]?.[0];
                const branchGod = getTenGod(dayStem, mainHiddenStem);

                const stemFortune = nenunFortunes[stemGod]?.[strengthType] || '－';
                const branchFortune = nenunFortunes[branchGod]?.[strengthType] || '－';

                let fortuneHTML = '';
                if (stemGod) {
                    fortuneHTML += `<div><strong>${stemGod}の運気（表面的）:</strong><br>${stemFortune}</div>`;
                }
                if (branchGod && stemGod !== branchGod) {
                    fortuneHTML += `<div style="margin-top:8px;"><strong>${branchGod}の運気（本質的）:</strong><br>${branchFortune}</div>`;
                } else if (branchGod && stemGod === branchGod) {
                     fortuneHTML += `<div style="margin-top:8px;">(本質的にも同じ運気です)</div>`;
                }

                nenunHTML += `<tr>
                    <td>${year}年</td>
                    <td>${yearPillar.stem}${yearPillar.branch}</td>
                    <td>${stemGod || '－'}</td>
                    <td>${branchGod || '－'}</td>
                    <td>${fortuneHTML}</td>
                </tr>`;
            }
            nenunHTML += '</table>';
            
            document.getElementById('nenunResult').innerHTML = nenunHTML;
            document.getElementById('nenunSection').style.display = 'block';
        }
        
        // This function is called by the new "recalculate" button for Nenun
        function updateNenun() {
            const dayStem = document.getElementById('dayStem').value;
            const strength = document.querySelector('.analysis-item:nth-child(4) > div:last-child').textContent;
            if (dayStem && strength) {
                calculateNenun(dayStem, strength);
            }
        }

    </script>
</body>
</html>
